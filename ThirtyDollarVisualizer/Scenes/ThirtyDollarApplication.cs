using System.Diagnostics;
using System.Runtime.InteropServices;
using OpenTK.Mathematics;
using OpenTK.Windowing.GraphicsLibraryFramework;
using SixLabors.Fonts;
using ThirtyDollarConverter.Objects;
using ThirtyDollarEncoder.PCM;
using ThirtyDollarEncoder.Wave;
using ThirtyDollarParser;
using ThirtyDollarParser.Custom_Events;
using ThirtyDollarVisualizer.Audio;
using ThirtyDollarVisualizer.Base_Objects;
using ThirtyDollarVisualizer.Base_Objects.Planes;
using ThirtyDollarVisualizer.Base_Objects.Settings;
using ThirtyDollarVisualizer.Base_Objects.Text;
using ThirtyDollarVisualizer.Base_Objects.Textures.Static;
using ThirtyDollarVisualizer.Helpers.Color;
using ThirtyDollarVisualizer.Helpers.Decoders;
using ThirtyDollarVisualizer.Helpers.Miscellaneous;
using ThirtyDollarVisualizer.Helpers.Positioning;
using ThirtyDollarVisualizer.Objects;
using ThirtyDollarVisualizer.Objects.Playfield;
using ThirtyDollarVisualizer.Renderer.Shaders;
using ThirtyDollarVisualizer.Settings;

namespace ThirtyDollarVisualizer.Scenes;

public sealed class ThirtyDollarApplication : ThirtyDollarWorkflow, IScene
{
    private const string Version = "2.0.0 (Insider Build)";
    private readonly DollarStoreCamera _camera;
    private readonly FpsCounter _fpsCounter = new();

    private readonly Lazy<Layout> _overlay;
    private Layout Overlay => _overlay.Value;

    private readonly VisualizerSettings _settings;
    private readonly List<Renderable> _startObjects = [];
    private readonly DollarStoreCamera _staticCamera;
    private readonly DollarStoreCamera _tempCamera;
    private readonly DollarStoreCamera _textCamera;
    private readonly CancellationTokenSource _tokenSource = new();

    private BackgroundPlane _backgroundPlane = null!;
    private BackingAudio? _backingAudio;
    private int _currentSequence;


    private SoundRenderable? _dragNDrop;
    private ColoredPlane _flashOverlay = null!;
    private CachedDynamicText? _greeting;
    private int _height;

    // These are needed for some events, because I don't want to pollute the placement events. They're polluted enough as they are.
    private float _lastBpm = 300f;
    private Manager _manager = null!;

    private Memory<Playfield> _playfields = Memory<Playfield>.Empty;

    private bool _tab;
    private ulong _updateId;
    private int _width;

    /// <summary>
    /// Creates a TDW sequence visualizer.
    /// </summary>
    /// <param name="width">The width of the visualizer.</param>
    /// <param name="height">The height of the visualizer.</param>
    /// <param name="sequenceLocations">The location of the sequence.</param>
    /// <param name="settings">The visualizer settings object this uses.</param>
    /// <param name="audioContext">The audio context the application will use.</param>
    public ThirtyDollarApplication(int width, int height, IEnumerable<string?> sequenceLocations,
        VisualizerSettings settings,
        AudioContext? audioContext = null) : base(audioContext)
    {
        _fileUpdateStopwatch = new Stopwatch();
        _seekDelayStopwatch = new Stopwatch();

        _width = width;
        _height = height;
        Sequences = GetSequenceInfos(sequenceLocations);
        _settings = settings;

        _tempCamera = new DollarStoreCamera((0, -300f, 0), new Vector2i(_width, _height), settings.ScrollSpeed);
        _camera = new DollarStoreCamera((0, -300f, 0), new Vector2i(_width, _height), settings.ScrollSpeed);
        _staticCamera = new DollarStoreCamera((0, 0, 0), new Vector2i(_width, _height), settings.ScrollSpeed);
        _textCamera = new DollarStoreCamera((0, 0, 0), new Vector2i(_width, _height), settings.ScrollSpeed);

        _seekDelayStopwatch.Start();
        _fileUpdateStopwatch.Start();

        _camera.OnZoom = zoom =>
        {
            UpdateStaticRenderables(_width, _height, zoom);
            SetStatusMessage($"[Camera]: Setting zoom to: {zoom:0.##%}");
        };
        
        _overlay = new Lazy<Layout>(() => CreateLayout(_width, _height));
    }
    
    private Layout CreateLayout(int width, int height)
    {
        var overlay = new Layout(width, height);
        
        overlay.Add<StaticText>("version",
            text =>
            {
                text.FontStyle = FontStyle.Bold;
                text.FontSizePx = 14f * Scale;
                text.Value = $"""
                              Don't use the audio generated by this
                              visualizer for a video, as it isn't
                              accurate at the moment. Use the
                              Thirty Dollar Converter instead.

                              Check regularly for updates at:
                              https://github.com/t1stm/ThirtyDollarTools

                              Current Version: {Version}
                              """;
            },
            (text, _, h) => { text.SetPosition((10, h, 0), PositionAlign.BottomLeft); });

        overlay.Add<StaticText>("controls",
            text =>
            {
                text.FontStyle = FontStyle.Bold;
                text.FontSizePx = 14f * Scale;
                text.Value = """
                             All controls:

                             Scroll -> Scroll up / down.
                             Ctrl+Scroll -> Change the zoom.
                             Up / Down -> Control the application's volume.
                             Left / Right -> Seek the sequence.
                             R -> Reload the current sequence.
                             C -> Change the camera modes.
                             F -> Toggle between fullscreen and windowed.
                             Space -> Pause / resume the sequence.
                             Escape -> Close the program.
                             0-9 -> Seek to bookmark.
                             Ctrl+0-9 -> Set bookmark to current time.
                             Ctrl+Shift+0-9 -> Clear given bookmark time.
                             Ctrl+D -> Show debugging info.
                             Page Up/Down -> Seek to previous/next sequence.

                             """;
                text.SetPosition((10, 100, 0));
            });

        overlay.Add<BasicDynamicText>("debug",
            text =>
            {
                text.FontStyle = FontStyle.Bold;
                text.FontSizePx = 14f * Scale;
                text.SetPosition((10, 30, 0));
            });

        overlay.Add<CachedDynamicText>("log",
            text =>
            {
                text.FontStyle = FontStyle.Bold;
                text.FontSizePx = 48f * Scale;
                text.SetPosition((20, 20, 0));
            });

        overlay.Add<CachedDynamicText>("update",
            text =>
            {
                text.FontStyle = FontStyle.Bold;
                text.SetPosition((10, 10, 0));
            });

        return overlay;
    }

    private static Vector4 DefaultBackgroundColor => new(0.21f, 0.22f, 0.24f, 1f);

    private CancellationToken Token => _tokenSource.Token;
    public int RenderableSize => _settings.EventSize;
    public int MarginBetweenRenderables => _settings.EventMargin;
    public int ElementsOnSingleLine => _settings.LineAmount;
    public CameraFollowMode CameraFollowMode { get; set; } = CameraFollowMode.TDWLike;
    public string? BackgroundVertexShaderLocation { get; init; }
    public string? BackgroundFragmentShaderLocation { get; init; }
    public float Scale { get; set; } = 1f;
    public string? Greeting { get; set; }
    private double SequenceVolume { get; set; }

    /// <summary>
    /// This method loads the sequence, textures and sounds.
    /// </summary>
    /// <exception cref="Exception">Exception thrown when one of the arguments is invalid.</exception>
    public void Init(Manager manager)
    {
        Manager.CheckErrors("PreInit");
        GetSampleHolder().GetAwaiter();
        _startObjects.Clear();

        _manager = manager;

        Log("Loaded sequence and placement.");

        Shader? optional_shader = null;
        if (BackgroundVertexShaderLocation is not null && BackgroundFragmentShaderLocation is not null)
            optional_shader = ShaderPool.GetOrLoad("bg_optional_shader",
                () => Shader.NewVertexFragment(BackgroundVertexShaderLocation, BackgroundFragmentShaderLocation));
        
        _backgroundPlane = new BackgroundPlane(DefaultBackgroundColor)
        {
            Position = new Vector3(-_width, -_height, -1f),
            Scale = new Vector3(_width * 2, _height * 2, -1f)
        };
        Manager.CheckErrors("Background");

        if (optional_shader is not null)
            _backgroundPlane.Shader = optional_shader;

        _flashOverlay = new ColoredPlane
        {
            Position = new Vector3(-_width, -_height, 1),
            Scale = new Vector3(_width * 2, _height * 2, 1),
            Color = new Vector4(1f, 1f, 1f, 0f)
        };
        Manager.CheckErrors("Flash");

        var font_family = Fonts.GetFontFamily();
        var greeting_font = font_family.CreateFont(36 * Scale, FontStyle.Bold);

        _greeting ??= new CachedDynamicText
        {
            FontStyle = FontStyle.Bold,
            FontSizePx = 36f * Scale,
            Value = Greeting ?? "DON'T LECTURE ME WITH YOUR THIRTY DOLLAR VISUALIZER"
        }.WithPosition((_width / 2f, -200f, 0.25f), PositionAlign.Center);
        Manager.CheckErrors("Greeting");

        UpdateStaticRenderables(_width, _height, Scale);
        Log = str => SetStatusMessage(str, 3500);

        if (_dragNDrop == null)
        {
            var dnd_texture = new FontTexture(greeting_font, "Drop files on the window to start.");
            _dragNDrop = new SoundRenderable(dnd_texture,
                new Vector3(_width / 2f - dnd_texture.Width / 2f, 0, 0.25f),
                new Vector2(dnd_texture.Width, dnd_texture.Height));

            _startObjects.Add(_dragNDrop);
            _dragNDrop.UpdateModel(false);
        }
        
        var resolution = manager.FramebufferSize; 
        Resize(resolution.X, resolution.Y);
        
        Manager.CheckErrors("Init End");
        
        if (Sequences.Length < 1) return;

        try
        {
            UpdateSequences(Sequences.ToArray().Select(s => s.FileLocation).ToArray()).GetAwaiter().GetResult();
        }
        catch (Exception e)
        {
            SetStatusMessage($"[Sequence Loader] Failed to load sequence with error: \'{e}\'", 10000);
        }
    }

    public void Resize(int w, int h)
    {
        var resize = new Vector2i(w, h);
        _textCamera.Viewport = _staticCamera.Viewport = _camera.Viewport = resize;

        _camera.UpdateMatrix();
        _staticCamera.UpdateMatrix();
        _textCamera.UpdateMatrix();

        foreach (var r in _startObjects)
        {
            var pos = r.Position;
            var delta_x = (_width - w) / 2f;

            pos -= delta_x * Vector3.UnitX;
            r.SetPosition(pos);
        }

        _greeting?.SetPosition(_greeting.Position - (_width - w) / 2f * Vector3.UnitX);
        Overlay.Resize(w, h);
        UpdateStaticRenderables(w, h, _camera.GetRenderScale());

        _width = w;
        _height = h;
    }

    public async void Start()
    {
        try
        {
            if (Sequences.Length < 1) return;
            await SequencePlayer.Stop();
            await SequencePlayer.Start();
        }
        catch (Exception)
        {
            // ignored
        }
    }

    public void Render()
    {
        // get static values from current camera, for this frame
        var camera = _tempCamera;
        camera.CopyFrom(_camera);

        // render background
        _backgroundPlane.Render(_staticCamera);

        // renders the flash overlay
        _flashOverlay.Render(_staticCamera);

        // render the greeting
        _greeting?.Render(camera);

        var clamped_scale = Math.Min(camera.GetRenderScale(), 1f);
        var width_scale = _width / clamped_scale - _width;
        var camera_x = camera.Position.X - width_scale;
        var camera_y = camera.Position.Y;
        var camera_xw = camera_x + _width + width_scale;
        var camera_yh = camera_y + _height;

        // render playfields
        if (_playfields.Length > 0)
        {
            var current_playfield = _playfields.Span[_currentSequence];
            current_playfield.Render(camera, camera.GetRenderScale(), (float)_manager.UpdateTime);
            current_playfield.DisplayCenter = !_tab;
        }

        // renders all start objects, when visible
        foreach (var renderable in _startObjects) RenderRenderable(renderable);

        // renders the static layout
        Overlay.Render(_textCamera);
        return;

        // inline method that is called in the renderer
        void RenderRenderable(Renderable? renderable)
        {
            if (renderable is null) return;

            var position = renderable.Position;
            var translation = renderable.Translation;

            var scale = renderable.Scale;
            var place = position + translation;

            // Bounds checks for viewport.

            if (place.X + scale.X < camera_x || place.X - scale.X > camera_xw) return;
            if (place.Y + scale.Y < camera_y || place.Y - scale.Y > camera_yh) return;

            renderable.Render(camera);
        }
    }

    public void Update()
    {
        // check if one of the sequences has been updated, and handle it
        if (_fileUpdateStopwatch.ElapsedMilliseconds > 250) HandleIfSequenceUpdate();

        var last_frame_time = (float)_manager.UpdateTime;

        // spawns the camera update thread
        _camera.Update(last_frame_time);

        // updates the background's transitions
        _backgroundPlane.Update();

        // sets debug values if debugging is enabled.
        RunDebugUpdate();

        // checks if there is a backing audio
        if (_backingAudio is null) return;

        // syncs the backing audio to the current sequence time
        var stopwatch = SequencePlayer.GetTimingStopwatch();
        _backingAudio.UpdatePlayState(stopwatch.IsRunning);
        _backingAudio.SyncTime(stopwatch.Elapsed);
    }

    public void Close()
    {
        SequencePlayer.Die();
        _camera.Die();
    }

    public void FileDrop(string?[] locations)
    {
        switch (locations.Length)
        {
            case < 1:
                return;
            case 1:
                if (locations[0]?.EndsWith(".wav") ?? false)
                {
                    UpdateBackingTrack(locations[0]!);
                    return;
                }

                break;
        }

        FileDrop(locations, true);
    }

    public void Mouse(MouseState mouseState, KeyboardState keyboardState)
    {
        // gets scroll
        var scroll = mouseState.ScrollDelta;
        if (scroll == Vector2.Zero) return;

        var new_delta = Vector3.UnitY * (scroll.Y * 100f);

        // if control is pressed handle zoom
        if (keyboardState.IsKeyDown(Keys.LeftControl) || keyboardState.IsKeyDown(Keys.RightControl))
            _camera.ZoomStep(scroll.Y);
        // otherwise scrolls the camera
        else
            _camera.ScrollDelta(new_delta);
    }

    public async void Keyboard(KeyboardState state)
    {
        const int seekLength = 1000;
        var stopwatch = SequencePlayer.GetTimingStopwatch();

        // extract modifier buttons
        var left_control = state.IsKeyDown(Keys.LeftControl);
        var right_control = state.IsKeyDown(Keys.RightControl);
        var left_shift = state.IsKeyDown(Keys.LeftShift);
        var right_shift = state.IsKeyDown(Keys.RightShift);

        // generic modifier checks
        var control = left_control || right_control;
        var shift = left_shift || right_shift;

        // toggle play / pause
        switch (state.IsKeyPressed(Keys.Space))
        {
            case true:
                SequencePlayer.TogglePause();
                if (!shift)
                    SetStatusMessage(SequencePlayer.GetTimingStopwatch().IsRunning switch
                    {
                        true => "[Playback]: Resumed",
                        false => "[Playback]: Paused"
                    }, 500);
                break;
        }

        // toggle camera modes
        var old_camera = CameraFollowMode;
        CameraFollowMode = state.IsKeyPressed(Keys.C) switch
        {
            true when CameraFollowMode is CameraFollowMode.None => CameraFollowMode.CurrentLine,
            true when CameraFollowMode is CameraFollowMode.CurrentLine => CameraFollowMode.TDWLike,
            true when CameraFollowMode is CameraFollowMode.TDWLike => CameraFollowMode.NoAnimationCurrentLine,
            true when CameraFollowMode is CameraFollowMode.NoAnimationCurrentLine => CameraFollowMode
                .NoAnimationTDW,
            true when CameraFollowMode is CameraFollowMode.NoAnimationTDW => CameraFollowMode.None,
            _ => CameraFollowMode
        };

        if (state.IsKeyPressed(Keys.Tab)) _tab = !_tab;

        // toggle fullscreen
        if (state.IsKeyPressed(Keys.F)) _manager.ToggleFullscreen();

        // bookmark handlers
        switch (left_control)
        {
            case true when left_shift:
            {
                for (var i = 0; i < 10; i++)
                {
                    var key = (Keys)((int)Keys.D0 + i);
                    if (!state.IsKeyPressed(key)) continue;
                    SequencePlayer.ClearBookmark(i);
                    SetStatusMessage($"[Playback] Cleared Bookmark: {i}");
                }

                break;
            }
            case true:
            {
                for (var i = 0; i < 10; i++)
                {
                    var key = (Keys)((int)Keys.D0 + i);
                    if (!state.IsKeyPressed(key)) continue;
                    var bookmark_time = SequencePlayer.SetBookmark(i);
                    SetStatusMessage($"[Playback] Setting Bookmark {i} To: {TimeString(bookmark_time)}");
                }

                if (state.IsKeyDown(Keys.Equal) && IsSeekTimeoutPassed(5))
                {
                    RestartSeekTimer();
                    _camera.ZoomStep(+1);
                }

                if (state.IsKeyDown(Keys.Minus) && IsSeekTimeoutPassed(5))
                {
                    RestartSeekTimer();
                    _camera.ZoomStep(-1);
                }

                if (state.IsKeyPressed(Keys.D))
                {
                    Debug = !Debug;
                    Overlay.Get<TextRenderable>("debug").IsVisible = Debug;
                    SetStatusMessage(Debug switch
                    {
                        true => "[Debug]: Enabled",
                        false => "[Debug]: Disabled"
                    });
                }

                break;
            }

            default:
            {
                for (var i = 0; i < 10; i++)
                {
                    var key = (Keys)((int)Keys.D0 + i);
                    if (!state.IsKeyPressed(key)) continue;
                    var time = await SequencePlayer.SeekToBookmark(i);
                    SetStatusMessage($"[Playback] Seeking To Bookmark {i}: {TimeString(time)}");
                }

                break;
            }
        }

        // set message if camera mode is updated
        if (old_camera != CameraFollowMode) SetStatusMessage($"[Camera] Follow Mode is now: {CameraFollowMode}");

        // check backwards seeking
        var elapsed = stopwatch.ElapsedMilliseconds;
        if (state.IsKeyDown(Keys.Left) && IsSeekTimeoutPassed())
        {
            RestartSeekTimer();
            var seek = seekLength;
            if (shift)
            {
                seek /= 10;
                if (control) seek /= 10;
            }

            var change = Math.Max(elapsed - seek, 0);

            SetStatusMessage($"[Playback]: Seeking To: {TimeString(change)}");
            await SequencePlayer.Seek(change);
        }

        // check forwards seeking
        if (state.IsKeyDown(Keys.Right) && IsSeekTimeoutPassed())
        {
            RestartSeekTimer();
            var seek = seekLength;
            if (shift)
            {
                seek /= 10;
                if (control) seek /= 10;
            }

            var change = elapsed + seek;

            SetStatusMessage($"[Playback]: Seeking To: {TimeString(change)}");
            await SequencePlayer.Seek(change);
        }

        // check volume increase
        if (state.IsKeyDown(Keys.Up) && IsSeekTimeoutPassed(7))
        {
            RestartSeekTimer();
            SequencePlayer.AudioContext.GlobalVolume += 0.01f;
            SetStatusMessage($"[Playback]: Global Volume = {SequencePlayer.AudioContext.GlobalVolume * 100:0.##}%");
        }

        // check volume decrease
        if (state.IsKeyDown(Keys.Down) && IsSeekTimeoutPassed(7))
        {
            RestartSeekTimer();
            SequencePlayer.AudioContext.GlobalVolume = Math.Max(0f, SequencePlayer.AudioContext.GlobalVolume - 0.01f);
            SetStatusMessage($"[Playback]: Global Volume = {SequencePlayer.AudioContext.GlobalVolume * 100:0.##}%");
        }

        // check previous sequence seeking
        if (state.IsKeyDown(Keys.PageUp) && IsSeekTimeoutPassed() && SequenceIndices.Ends.Length > 0)
        {
            RestartSeekTimer();
            var requested_sequence = Math.Clamp(_currentSequence - 2, -1, SequenceIndices.Ends.Length - 1);
            if (requested_sequence == -1)
            {
                await SequencePlayer.Seek(0);
            }
            else
            {
                var (index, _) = SequenceIndices.Ends[requested_sequence];
                await SequencePlayer.Seek(SequencePlayer.GetTimeFromIndex(index));
            }

            SetStatusMessage(
                $"[Playback]: Seeking To Sequence ({requested_sequence + 2} - {SequenceIndices.Ends.Length})");
        }

        // check next sequence seeking
        if (state.IsKeyDown(Keys.PageDown) && IsSeekTimeoutPassed() && SequenceIndices.Ends.Length > 0)
        {
            RestartSeekTimer();
            var requested_sequence = Math.Clamp(_currentSequence, 0, SequenceIndices.Ends.Length - 1);
            var (index, _) = SequenceIndices.Ends[requested_sequence];

            await SequencePlayer.Seek(SequencePlayer.GetTimeFromIndex(index));
            SetStatusMessage(requested_sequence + 1 < SequenceIndices.Ends.Length
                ? $"[Playback]: Seeking To Sequence ({requested_sequence + 2} - {SequenceIndices.Ends.Length})"
                : "[Playback]: Seeking To The End");
        }

        // check for restarting the current sequences
        if (!state.IsKeyPressed(Keys.R)) return;
        if (control && shift)
        {
            FileDrop(Sequences.ToArray().Select(s => s.FileLocation).Where(File.Exists).ToArray(), true);
            return;
        }

        _camera.ScrollTo((0, -300, 0));
        await SequencePlayer.Seek(0);
        _backgroundPlane.TransitionToColor(DefaultBackgroundColor, 0.16f);
        if (shift) SequencePlayer.GetTimingStopwatch().Stop();
        ResetAllAnimations();
    }

    /// <summary>
    /// Call this method when there is a change to the objects of a given sequence.
    /// </summary>
    /// <param name="sequenceIndex">The changed sequence's index.</param>
    public void HandleSequenceChange(int sequenceIndex)
    {
        if (TimedEvents.Placement.Length <= 1) return;
        var old_sequence = _currentSequence;
        _currentSequence = sequenceIndex;

        if (old_sequence != _currentSequence)
        {
            // reset debugging values to their default ones
            SequenceVolume = 100d;
            _lastBpm = 300;
        }

        if (old_sequence >= _currentSequence) return;
        _camera.SetPosition((0, -300, 0));

        // values for the loop below
        var current_placement = SequencePlayer.PlacementIndex;
        var current_index = TimedEvents.Placement[current_placement].Index;
        var max_index_change = TimedEvents.TimingSampleRate / 2; // 500 ms
        var max_index = current_index + (ulong)max_index_change;

        // checks if there is a color event in the next 500ms
        for (var i = current_placement; i < TimedEvents.Placement.Length; i++)
        {
            var index = Math.Clamp(i, 0, TimedEvents.Placement.Length - 1);
            var placement = TimedEvents.Placement[index];
            if (placement.Index > max_index) break;
            if (placement.Event.SoundEvent is "!bg") return;
        }

        // changes the background color to the default one if there isn't a color event in the next 500ms
        _backgroundPlane.TransitionToColor(DefaultBackgroundColor, 0.33f);
    }

    /// <summary>
    /// Converts milliseconds to a time string.
    /// </summary>
    /// <param name="milliseconds">Milliseconds passed.</param>
    /// <returns>A formatted time string.</returns>
    private static string TimeString(long milliseconds)
    {
        var timespan = TimeSpan.FromMilliseconds(milliseconds);
        var format = "";

        if (timespan.Hours > 0)
            format += @"hh\:";

        format += @"mm\:ss\.ff";

        return timespan.ToString(format);
    }

    private void ResetAllAnimations()
    {
        var index = 0;
        foreach (var placement in TimedEvents.Placement)
        {
            var renderable = GetRenderable(placement, index);
            renderable?.ResetAnimations();

            if (placement.Event is EndEvent) index++;
        }
    }

    protected override async Task HandleAfterSequenceLoad(TimedEvents events)
    {
        _currentSequence = 0;
        foreach (var renderable in _startObjects) renderable.IsVisible = false;

        var controls = Overlay.Get<TextRenderable>("controls");
        var version = Overlay.Get<TextRenderable>("version");

        controls.IsVisible = false;
        version.IsVisible = false;

        _camera.ScrollTo((0, -300, 0));
        _backgroundPlane.TransitionToColor(DefaultBackgroundColor, 0.66f);

        var sequences_count = events.Sequences.Length;
        var playfields = new Playfield[sequences_count];

        Task.Run(() =>
        {
            foreach (var placement in events.Placement.Where(p =>
                         p.Event is { SoundEvent: "!divider", Value: > 0 and <= 9 }
                             or BookmarkEvent { Value: >= 0 and <= 9 }))
            {
                if (Token.IsCancellationRequested) return;
                var time = placement.Index * 1000f / events.TimingSampleRate;
                var idx = (int)placement.Event.Value;

                SequencePlayer.SetBookmarkTo(idx, (long)time);
            }
        }, Token).GetAwaiter();

        var playfield_settings = new PlayfieldSettings(RenderableSize, SampleHolder?.DownloadLocation ?? "./Sounds",
            Scale, ElementsOnSingleLine,
            RenderableSize, MarginBetweenRenderables);

        try
        {
            for (var index = 0; index < events.Sequences.Length; index++)
            {
                var sequence = events.Sequences[index];

                playfields[index] = new Playfield(playfield_settings);
                await playfields[index].UpdateSounds(sequence);
            }
        }
        catch (Exception e)
        {
            Log(e.ToString());
            throw;
        }

        await _manager.RenderBlock.WaitAsync(Token);
        _playfields = playfields;
        _manager.RenderBlock.Release();
        SequenceVolume = 100;
    }

    protected override void SetSequencePlayerSubscriptions(SequencePlayer player)
    {
        player.SubscribeSequenceChange(HandleSequenceChange);
        player.SubscribeActionToEvent(string.Empty, NormalSubscription);
        player.SubscribeActionToEvent("!speed", SpeedEventHandler);
        player.SubscribeActionToEvent("!bg", BackgroundEventHandler);
        player.SubscribeActionToEvent("!flash", FlashEventHandler);
        player.SubscribeActionToEvent("!pulse", PulseEventHandler);
        player.SubscribeActionToEvent("!loopmany", LoopManyEventHandler);
        player.SubscribeActionToEvent("!stop", StopEventHandler);
        player.SubscribeActionToEvent("!volume", VolumeEventHandler);
    }


    private void SetStatusMessage(string message, int hideAfterMs = 2000)
    {
        var update = Overlay.Get<TextRenderable>("update");

        if (update.Value == message) return;
        update.Value = message;
        unchecked
        {
            var old_id = ++_updateId;
            Task.Run(async () =>
            {
                if (hideAfterMs < 0) return;
                await Task.Delay(hideAfterMs, Token);
                if (old_id == _updateId)
                    update.Value = string.Empty;
            }, Token);
        }
    }

    private SoundRenderable? GetRenderable(Placement placement, int sequenceIndex)
    {
        if (sequenceIndex >= _playfields.Length) return null;

        var playfields = _playfields.Span;
        var objects = CollectionsMarshal.AsSpan(playfields[sequenceIndex].Objects);

        var len = objects.Length;
        var placement_idx = (int)placement.SequenceIndex;
        var element = placement_idx >= len || placement_idx < 0 ? null : objects[placement_idx];

        return element;
    }

    private void CameraBoundsCheck(Placement placement, int sequenceIndex)
    {
        var element = GetRenderable(placement, sequenceIndex);
        if (element == null) return;

        var position = element.Position + element.Translation;
        var scale = element.Scale;

        switch (CameraFollowMode)
        {
            case var follow_mode when follow_mode.HasFlag(CameraFollowMode.TDWLike):
            {
                float margin = RenderableSize;

                if (!_camera.IsOutsideOfCameraView(position, scale, margin) &&
                    placement.Event.SoundEvent is not "!divider") break;

                var pos = new Vector3(0, position.Y - margin, 0f);

                if (CameraFollowMode.HasFlag(CameraFollowMode.NoAnimation))
                {
                    _camera.SetPosition(pos);
                    return;
                }

                _camera.ScrollTo(pos);
                return;
            }

            case var follow_mode when follow_mode.HasFlag(CameraFollowMode.CurrentLine):
            {
                var pos = position * Vector3.UnitY - Vector3.UnitY * (_height / 2f);

                if (CameraFollowMode.HasFlag(CameraFollowMode.NoAnimation))
                {
                    _camera.SetPosition(pos);
                    return;
                }

                _camera.ScrollTo(pos);
                return;
            }
        }
    }

    private void NormalSubscription(Placement placement, int index)
    {
        var element = GetRenderable(placement, index);
        if (element == null) return;
        CameraBoundsCheck(placement, index);

        if ((placement.Event.SoundEvent?.StartsWith('!') ?? false) || placement.Event is ICustomActionEvent)
        {
            element.Fade();
            element.Expand();
        }
        else if (placement.Event is not ICustomActionEvent)
        {
            element.Bounce();
        }
    }

    private void SpeedEventHandler(Placement placement, int index)
    {
        var val = (float)placement.Event.Value;

        _lastBpm = placement.Event.ValueScale switch
        {
            ValueScale.None => val,
            ValueScale.Add => _lastBpm + val,
            ValueScale.Times => _lastBpm * val,
            ValueScale.Divide => _lastBpm / val,

            _ => _lastBpm
        };
    }

    private void BackgroundEventHandler(Placement placement, int index)
    {
        var (color, seconds) = BackgroundParser.ParseFromDouble(placement.Event.Value);
        _backgroundPlane.TransitionToColor(color, seconds);
    }

    private void FlashEventHandler(Placement placement, int index)
    {
        Task.Run(async () =>
        {
            await ColorTools.ChangeColor(_flashOverlay, new Vector4(1, 1, 1, 1), 0.125f);
            await ColorTools.ChangeColor(_flashOverlay, new Vector4(0, 0, 0, 0), 0.25f);
        }, Token);
    }

    private void PulseEventHandler(Placement placement, int index)
    {
        var parsed_value = (long)placement.Event.Value;
        var repeats = (byte)parsed_value;
        float frequency = (short)(parsed_value >> 8);

        var computed_frequency = frequency * 1000f / (_lastBpm / 60);
        _camera.Pulse(repeats, computed_frequency);
        _staticCamera.Pulse(repeats, computed_frequency);
    }

    private void LoopManyEventHandler(Placement placement, int sequenceIndex)
    {
        if (sequenceIndex >= _playfields.Length) return;

        var element = GetRenderable(placement, sequenceIndex);
        element?.SetValue(placement.Event, _playfields.Span[_currentSequence].DecreasingValuesCache,
            ValueChangeWrapMode.RemoveTexture);
    }

    private void StopEventHandler(Placement placement, int sequenceIndex)
    {
        if (sequenceIndex >= _playfields.Length) return;

        var element = GetRenderable(placement, sequenceIndex);
        element?.SetValue(placement.Event, _playfields.Span[_currentSequence].DecreasingValuesCache,
            ValueChangeWrapMode.ResetToDefault);
    }

    private void VolumeEventHandler(Placement placement, int index)
    {
        SequenceVolume = placement.Event.WorkingVolume;
    }

    private void RunDebugUpdate()
    {
        if (!Debug) return;

        // define values used in generating the debug string.
        var bpm = 300f;
        var elapsed_milliseconds = SequencePlayer.GetTimingStopwatch().ElapsedMilliseconds;
        var current_note = "None";
        var current_note_idx = 0;

        var next_note = "None";
        var next_note_idx = 0;
        var next_beat_ms = 0f;
        var beats_to_next_beat = 0f;

        var fps = _fpsCounter.GetAverageFPS(1 / _manager.UpdateTime);
        var audio_engine = SequencePlayer.AudioContext.Name;
        var volume = SequenceVolume;

        // remove full path from sequence filename.
        var sequence_location = "None";
        if (Sequences.Length > 0 && Sequences.Length > _currentSequence)
            sequence_location = Sequences.Span[_currentSequence].FileLocation;

        var folder_index = sequence_location.LastIndexOf(Path.DirectorySeparatorChar);
        if (folder_index != -1)
        {
            var temp_idx = folder_index + 1;
            if (temp_idx < sequence_location.Length)
                sequence_location = sequence_location[temp_idx..];
        }

        // get current info.
        var current_index = Math.Max(0, SequencePlayer.PlacementIndex - 1);
        var placement_length = TimedEvents.Placement.Length;

        // get accurate bpm info.
        foreach (var ev in ExtractedSpeedEvents)
        {
            if (ev.Index >= SequencePlayer.GetIndexFromTime(elapsed_milliseconds)) break;
            var val = (float)ev.Event.Value;

            bpm = ev.Event.ValueScale switch
            {
                ValueScale.None => val,
                ValueScale.Add => bpm + val,
                ValueScale.Times => bpm * val,
                ValueScale.Divide => bpm / val,

                _ => bpm
            };
        }

        // get next note info.
        if (current_index < placement_length)
        {
            var normalized_time = SequencePlayer.GetIndexFromTime(elapsed_milliseconds);
            var current_placement = TimedEvents.Placement[current_index];

            current_note_idx = (int)current_placement.SequenceIndex;
            current_note = current_placement.Event.SoundEvent ?? current_note;
            var current_time = current_placement.Index;

            for (var i = current_index; i < TimedEvents.Placement.Length; i++)
            {
                var i_placement = TimedEvents.Placement[i];
                var i_time = i_placement.Index;
                if (i_time == current_time) continue;

                var is_timing_event = !(i_placement.Audible && i_placement.Event.SoundEvent switch
                {
                    "!cut" => false,
                    "_pause" => false,
                    "!stop" => false,
                    "#icut" => false,
                    _ => true
                });

                if (is_timing_event) continue;

                next_note = i_placement.Event.SoundEvent;
                next_note_idx = (int)i_placement.SequenceIndex;
                if (i_time > normalized_time) next_beat_ms = (i_time - normalized_time) / 100f;
                beats_to_next_beat = next_beat_ms / 1000f * (bpm / 60f);
                break;
            }
        }

        var debug = Overlay.Get<TextRenderable>("debug");

        // generate debug string.
        debug.Value = $"""
                       [Debug]
                       FPS: {fps:0.##}
                       Audio Engine: "{audio_engine}"

                       Sequence ({_currentSequence + 1} - {Sequences.Length}): {sequence_location}
                       BPM: {bpm}
                       Time: {TimeString(elapsed_milliseconds)}
                       Volume: {volume:0.##}%

                       Current ({current_note_idx}): {current_note}
                       Next ({next_note_idx}): {next_note}
                       In: {next_beat_ms:0.##ms} / {beats_to_next_beat:0.##} beats

                       [OpenGL]
                       Version: {GLInfo.Version}
                       Renderer: {GLInfo.Renderer}
                       Max Texture Size: {GLInfo.MaxTexture2DSize}
                       Max Texture Layers: {GLInfo.MaxTexture2DLayers}

                       """;
    }

    private void UpdateStaticRenderables(int w, int h, float scale)
    {
        _staticCamera.SetRenderScale(scale);
        scale = Math.Min(scale, 1f);
        var width_scale = w / scale - w;
        var height_scale = h / scale - h;

        var background = _backgroundPlane.Scale;
        var b_z = _backgroundPlane.Position.Z;
        _backgroundPlane.Position = (-width_scale / 2f, -height_scale / 2f, b_z);
        _backgroundPlane.Scale = (w + width_scale, h + height_scale, background.Z);

        var flash = _flashOverlay.Scale;
        var f_z = _flashOverlay.Position.Z;
        _flashOverlay.Scale = (w + width_scale, h + height_scale, flash.Z);
        _flashOverlay.SetPosition((-width_scale / 2f, -height_scale / 2f, f_z));
    }

    private void UpdateBackingTrack(string location)
    {
        var decoder = new WaveDecoder();
        var file_stream = File.OpenRead(location);
        var pcm_data = decoder.Read(file_stream);

        var audio = pcm_data.ReadAsFloat32Array(true);

        if (audio == null) return;
        _backingAudio = new BackingAudio(SequencePlayer.GetContext(), audio, (int)pcm_data.SampleRate);
        _backingAudio.Play();
    }

    private void FileDrop(IReadOnlyCollection<string?> locations, bool resetTime)
    {
        var log = Overlay.Get<TextRenderable>("log");
        _camera.ScrollTo((0, -300, 0));

        if (locations.Count < 1) return;

        Task.Run(async () =>
        {
            log.Value = "Loading...";
            try
            {
                await UpdateSequences(locations.Where(File.Exists).ToArray(), resetTime);
            }
            catch (Exception e)
            {
                SetStatusMessage($"[Sequence Loader] Failed to load sequence with error: \'{e}\'", 10000);
            }
            finally
            {
                log.Value = string.Empty;
            }
        }, Token);
    }

    private bool IsSeekTimeoutPassed(int divide = 1)
    {
        const int seekTimeout = 250;
        return _seekDelayStopwatch.ElapsedMilliseconds > seekTimeout / divide;
    }

    private void RestartSeekTimer()
    {
        _seekDelayStopwatch.Restart();
    }

    #region Stopwatches

    private readonly Stopwatch _fileUpdateStopwatch;
    private readonly Stopwatch _seekDelayStopwatch;

    #endregion
}